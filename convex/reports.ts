/**
 * Reports queries and mutations
 */

import { v } from "convex/values";
import { query, mutation, internalMutation, internalQuery } from "./_generated/server";

/**
 * Get report by ID
 */
export const getById = query({
  args: { id: v.id("reports") },
  handler: async (ctx, args) => {
    return await ctx.db.get(args.id);
  },
});

/**
 * List reports by user (Clerk ID)
 * Sorted by endDate (report period) descending, not generation time
 */
export const listByUser = query({
  args: {
    userId: v.string(),
    limit: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const limit = args.limit ?? 50;
    return await ctx.db
      .query("reports")
      .withIndex("by_userId_and_endDate", (q) => q.eq("userId", args.userId))
      .order("desc")
      .take(limit);
  },
});

/**
 * List reports by GitHub login (fallback for users without Clerk ID)
 * Sorted by endDate (report period) descending, not generation time
 */
export const listByGhLogin = query({
  args: {
    ghLogin: v.string(),
    limit: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const limit = args.limit ?? 50;
    // Find all reports where userId matches the gh:login pattern
    const allReports = await ctx.db
      .query("reports")
      .order("desc")
      .take(limit * 2); // Get extra to filter

    const filteredReports = allReports.filter(
      (report) => report.userId === `gh:${args.ghLogin}`
    );

    // Sort by endDate descending (most recent report period first)
    filteredReports.sort((a, b) => b.endDate - a.endDate);

    return filteredReports.slice(0, limit);
  },
});

export const listByWindow = query({
  args: {
    userId: v.string(),
    startDate: v.number(),
    endDate: v.number(),
    scheduleType: v.union(v.literal("daily"), v.literal("weekly")),
    limit: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const limit = args.limit ?? 20;

    const reports = await ctx.db
      .query("reports")
      .withIndex("by_userId_and_schedule", (q) =>
        q.eq("userId", args.userId).eq("scheduleType", args.scheduleType)
      )
      .filter((q) =>
        q.and(
          q.eq(q.field("startDate"), args.startDate),
          q.eq(q.field("endDate"), args.endDate)
        )
      )
      .order("desc")
      .take(limit);

    return reports;
  },
});

/**
 * List all reports (for admin/debug)
 */
export const list = query({
  args: {
    limit: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const limit = args.limit ?? 50;
    return await ctx.db
      .query("reports")
      .withIndex("by_createdAt")
      .order("desc")
      .take(limit);
  },
});

/**
 * Get total count of all reports
 *
 * Efficient query for dashboard/statistics - returns count without loading data.
 * Use this instead of list() when you only need the total number.
 */
export const count = query({
  handler: async (ctx) => {
    const reports = await ctx.db.query("reports").collect();
    return reports.length;
  },
});

/**
 * Delete report
 */
export const deleteReport = mutation({
  args: { id: v.id("reports") },
  handler: async (ctx, args) => {
    await ctx.db.delete(args.id);
  },
});

/**
 * Update report userId (for fixing test data)
 */
export const updateUserId = mutation({
  args: {
    oldUserId: v.string(),
    newUserId: v.string(),
  },
  handler: async (ctx, args) => {
    // Find all reports with old userId
    const reports = await ctx.db
      .query("reports")
      .withIndex("by_userId_and_createdAt", (q) =>
        q.eq("userId", args.oldUserId)
      )
      .collect();

    // Update each report
    const updates = await Promise.all(
      reports.map((report) =>
        ctx.db.patch(report._id, { userId: args.newUserId })
      )
    );

    return {
      updated: updates.length,
      reports: reports.map((r) => ({ id: r._id, title: r.title })),
    };
  },
});

/**
 * Internal: Create report
 */
export const create = internalMutation({
  args: {
    userId: v.string(),
    title: v.string(),
    description: v.optional(v.string()),
    startDate: v.number(),
    endDate: v.number(),
    ghLogins: v.array(v.string()),
    markdown: v.string(),
    html: v.string(),
    json: v.optional(v.string()),
    citations: v.array(v.string()),
    promptVersion: v.string(),
    provider: v.string(),
    model: v.string(),
    generatedAt: v.number(),
    isAutoGenerated: v.optional(v.boolean()),
    scheduleType: v.optional(v.union(v.literal("daily"), v.literal("weekly"))),
    cacheKey: v.optional(v.string()),
    coverageScore: v.optional(v.number()),
    coverageBreakdown: v.optional(
      v.array(
        v.object({
          scopeKey: v.string(),
          used: v.number(),
          total: v.number(),
        })
      )
    ),
    sections: v.optional(
      v.array(
        v.object({
          title: v.string(),
          bullets: v.array(v.string()),
          citations: v.array(v.string()),
        })
      )
    ),
  },
  handler: async (ctx, args) => {
    const now = Date.now();
    return await ctx.db.insert("reports", {
      ...args,
      createdAt: now,
      updatedAt: now,
    });
  },
});

export const getByCacheKey = internalQuery({
  args: {
    cacheKey: v.string(),
  },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("reports")
      .withIndex("by_cacheKey", (q) => q.eq("cacheKey", args.cacheKey))
      .first();
  },
});
