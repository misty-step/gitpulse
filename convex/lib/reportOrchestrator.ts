"use node";

import { createHash } from "crypto";
import type { ActionCtx } from "../_generated/server";
import { api, internal } from "../_generated/api";
import type { Doc, Id } from "../_generated/dataModel";
import { buildReportContext } from "./reportContext";
import {
  generateDailyReportFromContext,
  generateWeeklyReportFromContext,
} from "./reportGenerator";
import { getPromptVersion } from "./prompts";
import { computeCoverageSummary } from "./coverage";
import { emitMetric } from "./metrics";

interface GenerateReportParams {
  userId: string; // Clerk user ID used in reports table
  user: Doc<"users">;
  kind: "daily" | "weekly";
  startDate: number;
  endDate: number;
}

export async function generateReportForUser(
  ctx: ActionCtx,
  params: GenerateReportParams
): Promise<Id<"reports"> | null> {
  const { user, kind, startDate, endDate } = params;

  if (!user.githubUsername) {
    console.warn(
      `[Reports] Cannot generate ${kind} report for user ${params.userId} - missing githubUsername`
    );
    return null;
  }

  const events = await ctx.runQuery(api.events.listByActor, {
    actorId: user._id,
    startDate,
    endDate,
    limit: 2000,
  });

  const repoIds = Array.from(new Set(events.map((event) => event.repoId)));
  const repoDocs = await Promise.all(
    repoIds.map((id) => ctx.runQuery(api.repos.getById, { id }))
  );
  const reposById = new Map<Id<"repos">, Doc<"repos"> | null>(
    repoIds.map((id, idx) => [id, repoDocs[idx] ?? null])
  );

  const { context, allowedUrls } = buildReportContext({
    events,
    reposById,
    startDate,
    endDate,
  });

  const generator =
    kind === "daily"
      ? generateDailyReportFromContext
      : generateWeeklyReportFromContext;

  const llmStart = Date.now();
  const generated = await generator(
    user.githubUsername,
    context,
    allowedUrls
  );
  const latencyMs = Date.now() - llmStart;

  const citationSet = new Set(
    generated.citations.map(normalizeUrl).filter((value): value is string =>
      Boolean(value)
    )
  );

  const coverage = computeCoverageSummary(
    events.map((event) => ({
      scopeKey: resolveScopeKey(event, reposById.get(event.repoId) ?? null),
      used: isEventCited(event, citationSet),
    }))
  );

  const cacheKey = buildCacheKey(kind, params.userId, startDate, endDate, events);
  const now = Date.now();

  const title =
    kind === "daily"
      ? `Daily Standup - ${new Date(endDate).toLocaleDateString()}`
      : `Weekly Retro - Week of ${new Date(startDate).toLocaleDateString()}`;
  const description =
    kind === "daily"
      ? `Automated daily standup for ${user.githubUsername}`
      : `Automated weekly retrospective for ${user.githubUsername}`;

  return await ctx.runMutation(internal.reports.create, {
    userId: params.userId,
    title,
    description,
    startDate,
    endDate,
    ghLogins: [user.githubUsername],
    markdown: generated.markdown,
    html: generated.html,
    citations: generated.citations,
    promptVersion: getPromptVersion(),
    provider: generated.provider,
    model: generated.model,
    generatedAt: now,
    isAutoGenerated: true,
    scheduleType: kind,
    cacheKey,
    coverageScore: coverage.coverageScore,
    coverageBreakdown: coverage.breakdown,
  });

  emitMetric("report_latency_ms", {
    userId: params.userId,
    kind,
    latencyMs,
    eventsConsidered: events.length,
  });

  emitMetric("llm_cost_usd", {
    userId: params.userId,
    kind,
    provider: generated.provider,
    model: generated.model,
    costUsd: estimateCost(generated.provider, generated.model, events.length),
  });
}

export function buildCacheKey(
  kind: string,
  userId: string,
  startDate: number,
  endDate: number,
  events: Doc<"events">[]
): string {
  const contentHashes = events
    .map((event) => event.contentHash ?? String(event._id))
    .sort()
    .join(",");

  return createHash("sha256")
    .update([kind, userId, startDate, endDate, contentHashes].join("|"))
    .digest("hex");
}

export function isEventCited(
  event: Doc<"events">,
  citationSet: Set<string>
): boolean {
  if (!citationSet.size) {
    return false;
  }

  const eventUrl = normalizeUrl(extractEventUrl(event));
  if (!eventUrl) {
    return false;
  }

  return citationSet.has(eventUrl);
}

export function normalizeUrl(url?: string | null): string | undefined {
  if (!url) {
    return undefined;
  }
  return url.replace(/\/$/, "").trim();
}

export function extractEventUrl(event: Doc<"events">): string | undefined {
  const metadata = (event.metadata ?? {}) as Record<string, any>;
  return (
    metadata?.url ??
    metadata?.html_url ??
    metadata?.htmlUrl ??
    metadata?.sourceUrl ??
    metadata?.commit?.html_url ??
    undefined
  );
}

export function resolveScopeKey(
  event: Doc<"events">,
  repo: Doc<"repos"> | null
): string {
  if (repo?.fullName) {
    return `repo:${repo.fullName}`;
  }
  return `repoId:${event.repoId}`;
}

export function estimateCost(provider: string, model: string, eventCount: number): number {
  // Rough placeholder: cost scales with event count to keep visibility in logs
  const base = provider === "google" ? 0.0005 : 0.0008;
  return Number((base * Math.max(eventCount, 1)).toFixed(6));
}
