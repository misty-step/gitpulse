"use node";

/**
 * Scheduled Report Generation
 *
 * Generates automated daily standup and weekly retro reports.
 * Called by cron jobs at user's preferred time (reportHourUTC).
 */

import { v } from "convex/values";
import { internalAction } from "../_generated/server";
import { api, internal } from "../_generated/api";
import { getPromptVersion } from "../lib/prompts";
import { buildReportContext } from "../lib/reportContext";
import {
  generateDailyReportFromContext,
  generateWeeklyReportFromContext,
  buildSyntheticDailyReport,
  buildSyntheticWeeklyReport,
} from "../lib/reportGenerator";

// Removed deprecated callGemini function - now using LLMClient abstraction

/**
 * Generate daily standup report
 *
 * Called by cron job every morning at user's reportHourUTC.
 * Skips generation if no activity in past 24 hours.
 */
export const generateDailyReport = internalAction({
  args: { userId: v.string() },
  handler: async (ctx, args) => {
    // Get user data
    const user = await ctx.runQuery(api.users.getByClerkId, {
      clerkId: args.userId,
    });

    if (!user || !user.githubUsername) {
      console.warn(`User ${args.userId} not found or missing GitHub username`);
      return;
    }

    // Calculate date range (yesterday, 24 hours)
    const now = Date.now();
    const endDate = now;
    const startDate = now - 24 * 60 * 60 * 1000;

    const events = await ctx.runQuery(api.events.listByActor, {
      actorId: user._id,
      startDate,
      endDate,
      limit: 1000,
    });

    const repoIds = Array.from(new Set(events.map((event) => event.repoId)));
    const repoDocs = await Promise.all(
      repoIds.map((id) => ctx.runQuery(api.repos.getById, { id }))
    );
    const reposById = new Map(
      repoIds.map((id, idx) => [id, repoDocs[idx] ?? null])
    );

    const { context, allowedUrls } = buildReportContext({
      events,
      reposById,
      startDate,
      endDate,
    });

    let report;
    try {
      report = await generateDailyReportFromContext(
        user.githubUsername,
        context,
        allowedUrls
      );
    } catch (error) {
      console.error(
        "[Reports] Daily report generation failed, storing synthetic fallback.",
        error
      );
      report = buildSyntheticDailyReport(user.githubUsername, context);
    }

    // Store report
    await ctx.runMutation(internal.reports.create, {
      userId: args.userId,
      title: `Daily Standup - ${new Date(endDate).toLocaleDateString()}`,
      description: `Automated daily standup for ${user.githubUsername}`,
      markdown: report.markdown,
      html: report.html,
      citations: report.citations,
      startDate,
      endDate,
      ghLogins: [user.githubUsername],
      promptVersion: getPromptVersion(),
      provider: report.provider,
      model: report.model,
      generatedAt: now,
      isAutoGenerated: true,
      scheduleType: "daily",
    });

    console.log(`Generated daily report for ${user.githubUsername}`);
  },
});

/**
 * Generate weekly retro report
 *
 * Called by cron job once a week at user's reportHourUTC + weeklyDayUTC.
 * Skips generation if no activity in past 7 days.
 */
export const generateWeeklyReport = internalAction({
  args: { userId: v.string() },
  handler: async (ctx, args) => {
    // Get user data
    const user = await ctx.runQuery(api.users.getByClerkId, {
      clerkId: args.userId,
    });

    if (!user || !user.githubUsername) {
      console.warn(`User ${args.userId} not found or missing GitHub username`);
      return;
    }

    // Calculate date range (last 7 days)
    const now = Date.now();
    const endDate = now;
    const startDate = now - 7 * 24 * 60 * 60 * 1000;

    const events = await ctx.runQuery(api.events.listByActor, {
      actorId: user._id,
      startDate,
      endDate,
      limit: 1000,
    });

    const repoIds = Array.from(new Set(events.map((event) => event.repoId)));
    const repoDocs = await Promise.all(
      repoIds.map((id) => ctx.runQuery(api.repos.getById, { id }))
    );
    const reposById = new Map(
      repoIds.map((id, idx) => [id, repoDocs[idx] ?? null])
    );

    const { context, allowedUrls } = buildReportContext({
      events,
      reposById,
      startDate,
      endDate,
    });

    let report;
    try {
      report = await generateWeeklyReportFromContext(
        user.githubUsername,
        context,
        allowedUrls
      );
    } catch (error) {
      console.error(
        "[Reports] Weekly report generation failed, storing synthetic fallback.",
        error
      );
      report = buildSyntheticWeeklyReport(user.githubUsername, context);
    }

    // Store report
    await ctx.runMutation(internal.reports.create, {
      userId: args.userId,
      title: `Weekly Retro - Week of ${new Date(startDate).toLocaleDateString()}`,
      description: `Automated weekly retrospective for ${user.githubUsername}`,
      markdown: report.markdown,
      html: report.html,
      citations: report.citations,
      startDate,
      endDate,
      ghLogins: [user.githubUsername],
      promptVersion: getPromptVersion(),
      provider: report.provider,
      model: report.model,
      generatedAt: now,
      isAutoGenerated: true,
      scheduleType: "weekly",
    });

    console.log(`Generated weekly report for ${user.githubUsername}`);
  },
});
