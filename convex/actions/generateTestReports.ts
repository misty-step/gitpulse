"use node";

/**
 * Test Report Generation Action
 *
 * Generates multiple test reports for QA purposes.
 * Can be called from Convex CLI to create sample reports across different time periods.
 *
 * Usage:
 *   npx convex run actions/generateTestReports:generate --userId "user_xxx"
 *
 * Note: Generates reports for historical date ranges to test navigation and variety.
 */

import { v } from "convex/values";
import { action } from "../_generated/server";
import { api, internal } from "../_generated/api";
import type { Doc, Id } from "../_generated/dataModel";
import { getPromptVersion } from "../lib/prompts";
import { buildReportContext } from "../lib/reportContext";
import {
  generateDailyReportFromContext,
  generateWeeklyReportFromContext,
  buildSyntheticDailyReport,
  buildSyntheticWeeklyReport,
} from "../lib/reportGenerator";
import { logger } from "../lib/logger.js";

export const generate = action({
  args: {
    userId: v.optional(v.string()), // Clerk user ID (optional)
    ghLogin: v.optional(v.string()), // GitHub login (alternative to userId)
  },
  handler: async (ctx, args) => {
    const startTime = Date.now();

    // Get user data - support both Clerk ID and GitHub login
    let user;
    if (args.userId) {
      logger.info(
        { userId: args.userId },
        "Starting test report generation for user",
      );
      user = await ctx.runQuery(api.users.getByClerkId, {
        clerkId: args.userId,
      });
    } else if (args.ghLogin) {
      logger.info(
        { ghLogin: args.ghLogin },
        "Starting test report generation for GitHub user",
      );
      user = await ctx.runQuery(api.users.getByGhLogin, {
        ghLogin: args.ghLogin,
      });
    } else {
      throw new Error("Must provide either userId or ghLogin");
    }

    if (!user) {
      throw new Error(`User not found`);
    }

    // Use clerkId if available, otherwise use a placeholder for testing
    const userIdForReports = user.clerkId || `gh:${user.ghLogin}`;
    const githubUsername = user.ghLogin;

    const results = {
      dailyReports: [] as string[],
      weeklyReports: [] as string[],
      errors: [] as string[],
    };

    const now = Date.now();

    // Generate 5 daily reports (yesterday, 2 days ago, 3 days ago, 4 days ago, 5 days ago)
    logger.info("Generating daily test reports");
    for (let daysAgo = 1; daysAgo <= 5; daysAgo++) {
      try {
        logger.info({ daysAgo }, "Generating daily report");

        // Calculate date range for this specific day
        const endDate = now - (daysAgo - 1) * 24 * 60 * 60 * 1000;
        const startDate = endDate - 24 * 60 * 60 * 1000;

        // Fetch events for this date range
        const events: Doc<"events">[] = await ctx.runQuery(
          api.events.listByActor,
          {
            actorId: user._id,
            startDate,
            endDate,
            limit: 1000,
          },
        );

        const repoIds = Array.from(
          new Set(events.map((event) => event.repoId)),
        );
        const repoDocs: Array<Doc<"repos"> | null> = await Promise.all(
          repoIds.map((id) => ctx.runQuery(api.repos.getById, { id })),
        );
        const reposById = new Map<Id<"repos">, Doc<"repos"> | null>(
          repoIds.map((id, idx) => [id, repoDocs[idx] ?? null]),
        );

        const { context, allowedUrls } = buildReportContext({
          events,
          reposById,
          startDate,
          endDate,
        });

        let report;
        try {
          report = await generateDailyReportFromContext(
            githubUsername,
            context,
            allowedUrls,
          );
        } catch (error) {
          logger.warn(
            { err: error, daysAgo },
            "Daily report generation failed, using synthetic fallback",
          );
          report = buildSyntheticDailyReport(githubUsername, context);
        }

        // Store report
        await ctx.runMutation(internal.reports.create, {
          userId: userIdForReports,
          title: `Daily Standup - ${new Date(endDate).toLocaleDateString()}`,
          description: `Test daily standup for ${githubUsername} (${daysAgo} days ago)`,
          markdown: report.markdown,
          html: report.html,
          citations: report.citations,
          startDate,
          endDate,
          ghLogins: [githubUsername],
          promptVersion: getPromptVersion(),
          provider: report.provider,
          model: report.model,
          generatedAt: now,
          isAutoGenerated: false, // Mark as manual/test generation
          scheduleType: "daily",
        });

        results.dailyReports.push(
          `Daily report ${daysAgo} days ago (${events.length} events)`,
        );
        logger.info(
          { daysAgo, eventCount: events.length },
          "Generated daily report",
        );
      } catch (error) {
        const errorMsg = `Failed to generate daily report ${daysAgo} days ago: ${
          error instanceof Error ? error.message : String(error)
        }`;
        logger.error({ err: error, daysAgo }, errorMsg);
        results.errors.push(errorMsg);
      }
    }

    // Generate 3 weekly reports (last week, 2 weeks ago, 3 weeks ago)
    logger.info("Generating weekly test reports");
    for (let weeksAgo = 1; weeksAgo <= 3; weeksAgo++) {
      try {
        logger.info({ weeksAgo }, "Generating weekly report");

        // Calculate date range for this specific week
        const endDate = now - (weeksAgo - 1) * 7 * 24 * 60 * 60 * 1000;
        const startDate = endDate - 7 * 24 * 60 * 60 * 1000;

        // Fetch events for this date range
        const events: Doc<"events">[] = await ctx.runQuery(
          api.events.listByActor,
          {
            actorId: user._id,
            startDate,
            endDate,
            limit: 1000,
          },
        );

        const repoIds = Array.from(
          new Set(events.map((event) => event.repoId)),
        );
        const repoDocs: Array<Doc<"repos"> | null> = await Promise.all(
          repoIds.map((id) => ctx.runQuery(api.repos.getById, { id })),
        );
        const reposById = new Map<Id<"repos">, Doc<"repos"> | null>(
          repoIds.map((id, idx) => [id, repoDocs[idx] ?? null]),
        );

        const { context, allowedUrls } = buildReportContext({
          events,
          reposById,
          startDate,
          endDate,
        });

        let report;
        try {
          report = await generateWeeklyReportFromContext(
            githubUsername,
            context,
            allowedUrls,
          );
        } catch (error) {
          logger.warn(
            { err: error, weeksAgo },
            "Weekly report generation failed, using synthetic fallback",
          );
          report = buildSyntheticWeeklyReport(githubUsername, context);
        }

        // Store report
        await ctx.runMutation(internal.reports.create, {
          userId: userIdForReports,
          title: `Weekly Retro - Week of ${new Date(startDate).toLocaleDateString()}`,
          description: `Test weekly retrospective for ${githubUsername} (${weeksAgo} weeks ago)`,
          markdown: report.markdown,
          html: report.html,
          citations: report.citations,
          startDate,
          endDate,
          ghLogins: [githubUsername],
          promptVersion: getPromptVersion(),
          provider: report.provider,
          model: report.model,
          generatedAt: now,
          isAutoGenerated: false, // Mark as manual/test generation
          scheduleType: "weekly",
        });

        results.weeklyReports.push(
          `Weekly report ${weeksAgo} weeks ago (${events.length} events)`,
        );
        logger.info(
          { weeksAgo, eventCount: events.length },
          "Generated weekly report",
        );
      } catch (error) {
        const errorMsg = `Failed to generate weekly report ${weeksAgo} weeks ago: ${
          error instanceof Error ? error.message : String(error)
        }`;
        logger.error({ err: error, weeksAgo }, errorMsg);
        results.errors.push(errorMsg);
      }
    }

    const duration = Date.now() - startTime;
    logger.info(
      {
        durationMs: duration,
        dailyReports: results.dailyReports.length,
        weeklyReports: results.weeklyReports.length,
        errors: results.errors.length,
      },
      "Test report generation completed",
    );

    return {
      success: results.errors.length === 0,
      dailyReportsGenerated: results.dailyReports.length,
      weeklyReportsGenerated: results.weeklyReports.length,
      totalReports: results.dailyReports.length + results.weeklyReports.length,
      details: {
        daily: results.dailyReports,
        weekly: results.weeklyReports,
      },
      errors: results.errors,
      durationMs: duration,
      message: `Generated ${results.dailyReports.length} daily and ${results.weeklyReports.length} weekly test reports`,
    };
  },
});
